import networkx as nx

def main():
    # Створюємо граф (той самий, що і в завданні 1)
    G = nx.Graph()
    edges = [
        ("Хрещатик", "Майдан Незалежності"),
        ("Хрещатик", "Театральна"),
        ("Хрещатик", "Арсенальна"),
        ("Театральна", "Золоті Ворота"),
        ("Театральна", "Університет"),
        ("Золоті Ворота", "Палац Спорту"),
        ("Золоті Ворота", "Лук'янівська"),
        ("Майдан Незалежності", "Поштова Площа"),
        ("Майдан Незалежності", "Площа Українських Героїв"),
        ("Площа Українських Героїв", "Палац Спорту"),
        ("Площа Українських Героїв", "Олімпійська"),
        ("Палац Спорту", "Кловська"),
        ("Кловська", "Печерська"),
        ("Печерська", "Дружби Народів")
    ]
    G.add_edges_from(edges)

    start_node = "Університет"
    end_node = "Печерська"

    print(f"Шукаємо шлях від '{start_node}' до '{end_node}'\n")

    # --- 1. DFS (Пошук у глибину) ---
    # NetworkX не має прямої функції dfs_path, тому ми використовуємо
    # ітеративний підхід для знаходження будь-якого шляху методом DFS.
    # Найпростіший спосіб засобами бібліотеки: побудувати дерево DFS і знайти шлях у ньому.
    try:
        # Будуємо дерево обходу DFS від стартової точки
        dfs_tree = nx.dfs_tree(G, source=start_node)
        # Шлях у цьому дереві є шляхом DFS
        dfs_path = nx.shortest_path(dfs_tree, source=start_node, target=end_node)
        print(f"Шлях DFS: {dfs_path}")
    except nx.NetworkXNoPath:
        print("Шлях DFS не знайдено.")
    except Exception as e:
        print(f"Помилка при пошуку DFS: {e}")


    # --- 2. BFS (Пошук у ширину) ---
    # Для незважених графів BFS знаходить найкоротший шлях.
    # nx.shortest_path за замовчуванням використовує BFS для незважених графів.
    try:
        bfs_path = nx.shortest_path(G, source=start_node, target=end_node)
        print(f"Шлях BFS: {bfs_path}")
    except nx.NetworkXNoPath:
        print("Шлях BFS не знайдено.")

    print("\n--- Пояснення ---")
    print("DFS: будує маршрут, заглиблюючись у першу знайдену гілку. Це часто дає довший і 'звивистий' шлях.")
    print("BFS: досліджує граф шар за шаром, тому гарантовано знаходить шлях з мінімальною кількістю переходів.")

if __name__ == "__main__":
    main()
